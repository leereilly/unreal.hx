/**
   * 
   * WARNING! This file was autogenerated by: 
   *  _   _ _____     ___   _   _ __   __ 
   * | | | |  ___|   /   | | | | |\ \ / / 
   * | | | | |__    / /| | | |_| | \ V /  
   * | | | |  __|  / /_| | |  _  | /   \  
   * | |_| | |___  \___  | | | | |/ /^\ \ 
   *  \___/\____/      |_/ \_| |_/\/   \/ 
   * 
   * This file was autogenerated by UE4HaxeExternGenerator using UHT definitions. It only includes UPROPERTYs and UFUNCTIONs. Do not modify it!
   * In order to add more definitions, create or edit a type with the same name/package, but with an `_Extra` suffix
**/
package unreal.gameplayabilities;


/**
  meta =(RestrictedToClasses="GameplayAbility")
**/
@:umodule("GameplayAbilities")
@:glueCppIncludes("AbilitySystemBlueprintLibrary.h")
@:uextern extern class UAbilitySystemBlueprintLibrary extends unreal.UBlueprintFunctionLibrary {
  static public function GetAbilitySystemComponent(Actor : unreal.AActor) : unreal.gameplayabilities.UAbilitySystemComponent;
  
  /**
    This function can be used to trigger an ability on the actor in question with useful payload data.
  **/
  static public function SendGameplayEventToActor(Actor : unreal.AActor, EventTag : unreal.gameplaytags.FGameplayTag, Payload : unreal.gameplayabilities.FGameplayEventData) : Void;
  
  /**
    Attribute
  **/
  static public function GetFloatAttribute(Actor : unreal.Const<unreal.AActor>, Attribute : unreal.gameplayabilities.FGameplayAttribute, bSuccessfullyFoundAttribute : Bool) : unreal.Float32;
  
  /**
    TargetData
  **/
  static public function AppendTargetDataHandle(TargetHandle : unreal.gameplayabilities.FGameplayAbilityTargetDataHandle, HandleToAdd : unreal.gameplayabilities.FGameplayAbilityTargetDataHandle) : unreal.gameplayabilities.FGameplayAbilityTargetDataHandle;
  static public function AbilityTargetDataFromLocations(SourceLocation : unreal.Const<unreal.PRef<unreal.gameplayabilities.FGameplayAbilityTargetingLocationInfo>>, TargetLocation : unreal.Const<unreal.PRef<unreal.gameplayabilities.FGameplayAbilityTargetingLocationInfo>>) : unreal.gameplayabilities.FGameplayAbilityTargetDataHandle;
  static public function AbilityTargetDataFromHitResult(HitResult : unreal.FHitResult) : unreal.gameplayabilities.FGameplayAbilityTargetDataHandle;
  static public function GetDataCountFromTargetData(TargetData : unreal.gameplayabilities.FGameplayAbilityTargetDataHandle) : unreal.Int32;
  static public function AbilityTargetDataFromActor(Actor : unreal.AActor) : unreal.gameplayabilities.FGameplayAbilityTargetDataHandle;
  static public function AbilityTargetDataFromActorArray(ActorArray : unreal.TArray<unreal.AActor>, OneTargetPerHandle : Bool) : unreal.gameplayabilities.FGameplayAbilityTargetDataHandle;
  
  /**
    Create a new target data handle with filtration performed on the data
  **/
  static public function FilterTargetData(TargetDataHandle : unreal.gameplayabilities.FGameplayAbilityTargetDataHandle, ActorFilterClass : unreal.gameplayabilities.FGameplayTargetDataFilterHandle) : unreal.gameplayabilities.FGameplayAbilityTargetDataHandle;
  
  /**
    Create a handle for filtering target data, filling out all fields
  **/
  static public function MakeFilterHandle(Filter : unreal.gameplayabilities.FGameplayTargetDataFilter, FilterActor : unreal.AActor) : unreal.gameplayabilities.FGameplayTargetDataFilterHandle;
  
  /**
    Create a spec handle, filling out all fields
  **/
  static public function MakeSpecHandle(InGameplayEffect : unreal.gameplayabilities.UGameplayEffect, InInstigator : unreal.AActor, InEffectCauser : unreal.AActor, InLevel : unreal.Float32) : unreal.gameplayabilities.FGameplayEffectSpecHandle;
  static public function GetActorsFromTargetData(TargetData : unreal.gameplayabilities.FGameplayAbilityTargetDataHandle, Index : unreal.Int32) : unreal.TArray<unreal.AActor>;
  
  /**
    Returns true if the given TargetData has the actor passed in targeted
  **/
  static public function DoesTargetDataContainActor(TargetData : unreal.gameplayabilities.FGameplayAbilityTargetDataHandle, Index : unreal.Int32, Actor : unreal.AActor) : Bool;
  
  /**
    Returns true if the given TargetData has at least 1 actor targeted
  **/
  static public function TargetDataHasActor(TargetData : unreal.gameplayabilities.FGameplayAbilityTargetDataHandle, Index : unreal.Int32) : Bool;
  static public function TargetDataHasHitResult(HitResult : unreal.gameplayabilities.FGameplayAbilityTargetDataHandle, Index : unreal.Int32) : Bool;
  static public function GetHitResultFromTargetData(HitResult : unreal.gameplayabilities.FGameplayAbilityTargetDataHandle, Index : unreal.Int32) : unreal.FHitResult;
  static public function TargetDataHasOrigin(TargetData : unreal.gameplayabilities.FGameplayAbilityTargetDataHandle, Index : unreal.Int32) : Bool;
  static public function GetTargetDataOrigin(TargetData : unreal.gameplayabilities.FGameplayAbilityTargetDataHandle, Index : unreal.Int32) : unreal.FTransform;
  static public function TargetDataHasEndPoint(TargetData : unreal.gameplayabilities.FGameplayAbilityTargetDataHandle, Index : unreal.Int32) : Bool;
  static public function GetTargetDataEndPoint(TargetData : unreal.gameplayabilities.FGameplayAbilityTargetDataHandle, Index : unreal.Int32) : unreal.FVector;
  static public function GetTargetDataEndPointTransform(TargetData : unreal.gameplayabilities.FGameplayAbilityTargetDataHandle, Index : unreal.Int32) : unreal.FTransform;
  
  /**
    GameplayEffectSpec
  **/
  static public function AssignSetByCallerMagnitude(SpecHandle : unreal.gameplayabilities.FGameplayEffectSpecHandle, DataName : unreal.FName, Magnitude : unreal.Float32) : unreal.gameplayabilities.FGameplayEffectSpecHandle;
  static public function SetDuration(SpecHandle : unreal.gameplayabilities.FGameplayEffectSpecHandle, Duration : unreal.Float32) : unreal.gameplayabilities.FGameplayEffectSpecHandle;
  
  /**
    This instance of the effect will now grant NewGameplayTag to the object that this effect is applied to.
  **/
  static public function AddGrantedTag(SpecHandle : unreal.gameplayabilities.FGameplayEffectSpecHandle, NewGameplayTag : unreal.gameplaytags.FGameplayTag) : unreal.gameplayabilities.FGameplayEffectSpecHandle;
  
  /**
    This instance of the effect will now grant NewGameplayTags to the object that this effect is applied to.
  **/
  static public function AddGrantedTags(SpecHandle : unreal.gameplayabilities.FGameplayEffectSpecHandle, NewGameplayTags : unreal.gameplaytags.FGameplayTagContainer) : unreal.gameplayabilities.FGameplayEffectSpecHandle;
  
  /**
    Adds NewGameplayTag to this instance of the effect.
  **/
  static public function AddAssetTag(SpecHandle : unreal.gameplayabilities.FGameplayEffectSpecHandle, NewGameplayTag : unreal.gameplaytags.FGameplayTag) : unreal.gameplayabilities.FGameplayEffectSpecHandle;
  
  /**
    Adds NewGameplayTags to this instance of the effect.
  **/
  static public function AddAssetTags(SpecHandle : unreal.gameplayabilities.FGameplayEffectSpecHandle, NewGameplayTags : unreal.gameplaytags.FGameplayTagContainer) : unreal.gameplayabilities.FGameplayEffectSpecHandle;
  static public function AddLinkedGameplayEffectSpec(SpecHandle : unreal.gameplayabilities.FGameplayEffectSpecHandle, LinkedGameplayEffectSpec : unreal.gameplayabilities.FGameplayEffectSpecHandle) : unreal.gameplayabilities.FGameplayEffectSpecHandle;
  
  /**
    Sets the GameplayEffectSpec's StackCount to the specified amount (prior to applying)
  **/
  static public function SetStackCount(SpecHandle : unreal.gameplayabilities.FGameplayEffectSpecHandle, StackCount : unreal.Int32) : unreal.gameplayabilities.FGameplayEffectSpecHandle;
  
  /**
    Sets the GameplayEffectSpec's StackCount to the max stack count defined in the GameplayEffect definition
  **/
  static public function SetStackCountToMax(SpecHandle : unreal.gameplayabilities.FGameplayEffectSpecHandle) : unreal.gameplayabilities.FGameplayEffectSpecHandle;
  
  /**
    Returns current stack count of an active Gameplay Effect. Will return 0 if the GameplayEffect is no longer valid.
  **/
  static public function GetActiveGameplayEffectStackCount(ActiveHandle : unreal.gameplayabilities.FActiveGameplayEffectHandle) : unreal.Int32;
  
}
