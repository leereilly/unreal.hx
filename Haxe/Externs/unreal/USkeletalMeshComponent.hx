/**
   * 
   * WARNING! This file was autogenerated by: 
   *  _   _ _____     ___   _   _ __   __ 
   * | | | |  ___|   /   | | | | |\ \ / / 
   * | | | | |__    / /| | | |_| | \ V /  
   * | | | |  __|  / /_| | |  _  | /   \  
   * | |_| | |___  \___  | | | | |/ /^\ \ 
   *  \___/\____/      |_/ \_| |_/\/   \/ 
   * 
   * This file was autogenerated by UE4HaxeExternGenerator using UHT definitions. It only includes UPROPERTYs and UFUNCTIONs. Do not modify it!
   * In order to add more definitions, create or edit a type with the same name/package, but with an `_Extra` suffix
**/
package unreal;


/**
  SkeletalMeshComponent is used to create an instance of an animated SkeletalMesh asset.
  
  @see https://docs.unrealengine.com/latest/INT/Engine/Content/Types/SkeletalMeshes/
  @see USkeletalMesh
**/
@:glueCppIncludes("Components/SkeletalMeshComponent.h")
@:uextern extern class USkeletalMeshComponent extends unreal.USkinnedMeshComponent implements unreal.IInterface_CollisionDataProvider {
  
  /**
    Keep track of when animation has been ticked to ensure it is ticked only once per frame.
  **/
  public var LastPoseTickTime : unreal.Float32;
  
  /**
    Threshold for physics asset bodies above which we use an aggregate for broadphase collisions
  **/
  public var RagdollAggregateThreshold : unreal.Int32;
  
  /**
    If bEnableLineCheckWithBounds is true, scale the bounds by this value before doing line check.
  **/
  public var LineCheckBoundsScale : unreal.FVector;
  
  /**
    If true, line checks will test against the bounding box of this skeletal mesh component and return a hit if there is a collision.
  **/
  public var bEnableLineCheckWithBounds : Bool;
  
  /**
    If true, AnimTree has been initialised.
  **/
  public var bAnimTreeInitialised : Bool;
  
  /**
    If false, indicates that on the next call to UpdateSkelPose the RequiredBones array should be recalculated.
  **/
  public var bRequiredBonesUpToDate : Bool;
  
  /**
    Bool that enables debug drawing of the skeleton before it is passed to the physics. Useful for debugging animation-driven physics.
  **/
  public var bShowPrePhysBones : Bool;
  
  /**
    If bForceRefPose was set last tick.
  **/
  public var bOldForceRefPose : Bool;
  
  /**
    If true, force the mesh into the reference pose - is an optimization.
  **/
  public var bForceRefpose : Bool;
  
  /**
    If true TickPose() will not be called from the Component's TickComponent function.
    It will instead be called from Autonomous networking updates. See ACharacter.
  **/
  public var bAutonomousTickPose : Bool;
  
  /**
    Used for per poly collision. In 99% of cases you will be better off using a Physics Asset.
    This BodySetup is per instance because all modification of vertices is done in place
  **/
  public var BodySetup : unreal.UBodySetup;
  
  /**
    Uses skinned data for collision data.
  **/
  public var bEnablePerPolyCollision : Bool;
  
  /**
    pauses this component's animations (doesn't tick them, but still refreshes bones)
  **/
  public var bPauseAnims : Bool;
  
  /**
    Skips Ticking and Bone Refresh.
  **/
  public var bNoSkeletonUpdate : Bool;
  
  /**
    Offset of the root bone from the reference pose. Used to offset bounding box.
  **/
  public var RootBoneTranslation : unreal.FVector;
  
  /**
    weight to blend between simulated results and key-framed positions
    if weight is 1.0, shows only cloth simulation results and 0.0 will show only skinned results
  **/
  public var ClothBlendWeight : unreal.Float32;
  
  /**
    rotation threshold in degree, ranging from 0 to 180
    conduct teleportation if the character's rotation is greater than this threshold in 1 frame.
    Zero or negative values will skip the check
  **/
  public var TeleportRotationThreshold : unreal.Float32;
  
  /**
    conduct teleportation if the character's movement is greater than this threshold in 1 frame.
    Zero or negative values will skip the check
    you can also do force teleport manually using ForceNextUpdateTeleport() / ForceNextUpdateTeleportAndReset()
  **/
  public var TeleportDistanceThreshold : unreal.Float32;
  
  /**
    reset the clothing after moving the clothing position (called teleport)
  **/
  public var bResetAfterTeleport : Bool;
  
  /**
    cloth morph target option
    This option will be applied only before playing because should do pre-calculation to reduce computation time for run-time play
    so it's impossible to change this option in run-time
  **/
  public var bClothMorphTarget : Bool;
  
  /**
    It's worth trying this option when you feel that the current cloth simulation is unstable.
    The scale of the actor is maintained during the simulation.
    It is possible to add the inertia effects to the simulation, through the inertiaScale parameter of the clothing material.
    So with an inertiaScale of 1.0 there should be no visible difference between local space and global space simulation.
    Known issues: - Currently there's simulation issues when this feature is used in 3.x (DE4076) So if localSpaceSim is enabled there's no inertia effect when the global pose of the clothing actor changes.
  **/
  public var bLocalSpaceSimulation : Bool;
  
  /**
    can't collide with part of attached children if total collision volumes exceed 16 capsules or 32 planes per convex
  **/
  public var bCollideWithAttachedChildren : Bool;
  
  /**
    can't collide with part of environment if total collision volumes exceed 16 capsules or 32 planes per convex
  **/
  public var bCollideWithEnvironment : Bool;
  
  /**
    Disable cloth simulation and play original animation without simulation
  **/
  public var bDisableClothSimulation : Bool;
  
  /**
    If we should pass joint position to joints each frame, so that they can be used by motorized joints to drive the
    ragdoll based on the animation.
  **/
  public var bUpdateJointsFromAnimation : Bool;
  
  /**
    If true, simulate physics for this component on a dedicated server.
    This should be set if simulating physics and replicating with a dedicated server.
  **/
  public var bEnablePhysicsOnDedicatedServer : Bool;
  
  /**
    Enables blending in of physics bodies whether Simulate or not
  **/
  public var bBlendPhysics : Bool;
  
  /**
    If we are running physics, should we update non-simulated bones based on the animation bone positions.
  **/
  public var KinematicBonesUpdateType : unreal.EKinematicBonesUpdateToPhysics;
  
  /**
    If true, there is at least one body in the current PhysicsAsset with a valid bone in the current SkeletalMesh
  **/
  public var bHasValidBodies : Bool;
  
  /**
    Used to scale speed of all animations on this skeletal mesh.
  **/
  public var GlobalAnimRateScale : unreal.Float32;
  
  /**
    Cached SpaceBases for Update Rate optimization.
  **/
  public var CachedSpaceBases : unreal.TArray<unreal.FTransform>;
  
  /**
    Cached LocalAtoms for Update Rate optimization.
  **/
  public var CachedLocalAtoms : unreal.TArray<unreal.FTransform>;
  public var AnimationData : unreal.FSingleAnimationPlayData;
  
  /**
    The active animation graph program instance.
  **/
  public var AnimScriptInstance : unreal.UAnimInstance;
  
  /**
    The AnimBlueprint class to use. Use 'SetAnimInstanceClass' to change at runtime.
  **/
  public var AnimBlueprintGeneratedClass : unreal.UAnimBlueprintGeneratedClass;
  #if WITH_EDITORONLY_DATA
  
  /**
    The blueprint for creating an AnimationScript.
  **/
  public var AnimationBlueprint_DEPRECATED : unreal.UAnimBlueprint;
  #end // WITH_EDITORONLY_DATA
  
  /**
    Whether to use Animation Blueprint or play Single Animation Asset.
  **/
  private var AnimationMode : unreal.EAnimationMode;
  @:final public function SetAnimInstanceClass(NewClass : unreal.UClass) : Void;
  
  /**
    Returns the animation instance that is driving the class (if available). This is typically an instance of
    the class set as AnimBlueprintGeneratedClass (generated by an animation blueprint)
  **/
  @:thisConst @:final public function GetAnimInstance() : unreal.UAnimInstance;
  
  /**
    Below are the interface to control animation when animation mode, not blueprint mode *
  **/
  @:final public function SetAnimationMode(InAnimationMode : unreal.EAnimationMode) : Void;
  @:thisConst @:final public function GetAnimationMode() : unreal.EAnimationMode;
  @:final public function PlayAnimation(NewAnimToPlay : unreal.UAnimationAsset, bLooping : Bool) : Void;
  @:final public function SetAnimation(NewAnimToPlay : unreal.UAnimationAsset) : Void;
  @:final public function Play(bLooping : Bool) : Void;
  @:final public function Stop() : Void;
  @:thisConst @:final public function IsPlaying() : Bool;
  @:final public function SetPosition(InPos : unreal.Float32, bFireNotifies : Bool) : Void;
  @:thisConst @:final public function GetPosition() : unreal.Float32;
  @:final public function SetPlayRate(Rate : unreal.Float32) : Void;
  @:thisConst @:final public function GetPlayRate() : unreal.Float32;
  
  /**
    Set Morph Target with Name and Value(0-1)
    
    @param bRemoveZeroWeight : Used by editor code when it should stay in the active list with zero weight
  **/
  @:final public function SetMorphTarget(MorphTargetName : unreal.FName, Value : unreal.Float32, bRemoveZeroWeight : Bool) : Void;
  
  /**
    Clear all Morph Target that are set to this mesh
  **/
  @:final public function ClearMorphTargets() : Void;
  
  /**
    Get Morph target with given name
  **/
  @:thisConst @:final public function GetMorphTarget(MorphTargetName : unreal.FName) : unreal.Float32;
  
  /**
    Get/Set the max distance scale of clothing mesh vertices
  **/
  @:final public function GetClothMaxDistanceScale() : unreal.Float32;
  @:final public function SetClothMaxDistanceScale(Scale : unreal.Float32) : Void;
  
  /**
    Used to indicate we should force 'teleport' during the next call to UpdateClothState,
    This will transform positions and velocities and thus keep the simulation state, just translate it to a new pose.
  **/
  @:final public function ForceClothNextUpdateTeleport() : Void;
  
  /**
    Used to indicate we should force 'teleport and reset' during the next call to UpdateClothState.
    This can be used to reset it from a bad state or by a teleport where the old state is not important anymore.
  **/
  @:final public function ForceClothNextUpdateTeleportAndReset() : Void;
  
  /**
    Reset the teleport mode of a next update to 'Continuous'
  **/
  @:final public function ResetClothTeleportMode() : Void;
  
  /**
    If this component has a valid MasterPoseComponent then this function makes cloth items on the slave component
    take the transforms of the cloth items on the master component instead of simulating separately.
    @Note This will FORCE any cloth actor on the master component to simulate in local space. Also
    The meshes used in the components must be identical for the cloth to bind correctly
  **/
  @:final public function BindClothToMasterPoseComponent() : Void;
  
  /**
    If this component has a valid MasterPoseComponent and has previously had its cloth bound to the
    MCP, this function will unbind the cloth and resume simulation.
    @param bRestoreSimulationSpace if true and the master pose cloth was originally simulating in world
    space, we will restore this setting. This will cause the master component to reset which may be
    undesirable.
  **/
  @:final public function UnbindClothFromMasterPoseComponent(bRestoreSimulationSpace : Bool) : Void;
  
  /**
    Set bSimulatePhysics to true for all bone bodies. Does not change the component bSimulatePhysics flag.
  **/
  @:final public function SetAllBodiesSimulatePhysics(bNewSimulate : Bool) : Void;
  
  /**
    This is global set up for setting physics blend weight
    This does multiple things automatically
    If PhysicsBlendWeight == 1.f, it will enable Simulation, and if PhysicsBlendWeight == 0.f, it will disable Simulation.
    Also it will respect each body's setup, so if the body is fixed, it won't simulate. Vice versa
    So if you'd like all bodies to change manually, do not use this function, but SetAllBodiesPhysicsBlendWeight
  **/
  @:final public function SetPhysicsBlendWeight(PhysicsBlendWeight : unreal.Float32) : Void;
  
  /**
    Disable physics blending of bones *
  **/
  @:final public function SetEnablePhysicsBlending(bNewBlendPhysics : Bool) : Void;
  
  /**
    Set all of the bones below passed in bone to be simulated
  **/
  @:final public function SetAllBodiesBelowSimulatePhysics(InBoneName : unreal.Const<unreal.PRef<unreal.FName>>, bNewSimulate : Bool) : Void;
  
  /**
    Allows you to reset bodies Simulate state based on where bUsePhysics is set to true in the BodySetup.
  **/
  @:final public function ResetAllBodiesSimulatePhysics() : Void;
  @:final public function SetAllBodiesPhysicsBlendWeight(PhysicsBlendWeight : unreal.Float32, bSkipCustomPhysicsType : Bool) : Void;
  
  /**
    Set all of the bones below passed in bone to be simulated
  **/
  @:final public function SetAllBodiesBelowPhysicsBlendWeight(InBoneName : unreal.Const<unreal.PRef<unreal.FName>>, PhysicsBlendWeight : unreal.Float32, bSkipCustomPhysicsType : Bool) : Void;
  
  /**
    Accumulate AddPhysicsBlendWeight to physics blendweight for all of the bones below passed in bone to be simulated
  **/
  @:final public function AccumulateAllBodiesBelowPhysicsBlendWeight(InBoneName : unreal.Const<unreal.PRef<unreal.FName>>, AddPhysicsBlendWeight : unreal.Float32, bSkipCustomPhysicsType : Bool) : Void;
  
  /**
    Enable or Disable AngularPositionDrive. If motor is in SLERP mode it will be turned on if either EnableSwingDrive OR EnableTwistDrive are enabled. In Twist and Swing mode the twist and the swing can be controlled individually.
  **/
  @:final public function SetAllMotorsAngularPositionDrive(bEnableSwingDrive : Bool, bEnableTwistDrive : Bool, bSkipCustomPhysicsType : Bool) : Void;
  
  /**
    Enable or Disable AngularVelocityDrive. If motor is in SLERP mode it will be turned on if either EnableSwingDrive OR EnableTwistDrive are enabled. In Twist and Swing mode the twist and the swing can be controlled individually.
  **/
  @:final public function SetAllMotorsAngularVelocityDrive(bEnableSwingDrive : Bool, bEnableTwistDrive : Bool, bSkipCustomPhysicsType : Bool) : Void;
  
  /**
    Set Angular Drive motors params for all constraint instances
  **/
  @:final public function SetAllMotorsAngularDriveParams(InSpring : unreal.Float32, InDamping : unreal.Float32, InForceLimit : unreal.Float32, bSkipCustomPhysicsType : Bool) : Void;
  // Interface_CollisionDataProvider interface implementation
  
}
