/**
  This file was autogenerated by UE4HaxeExternGenerator using UHT definitions. It only includes UPROPERTYs and UFUNCTIONs. Do not modify it!
  In order to add more definitions, create or edit a type with the same name/package, but with a `_Extra` suffix
**/
package unreal;


/**
  SkeletalMeshComponent is used to create an instance of an animated SkeletalMesh asset.
  
  @see https://docs.unrealengine.com/latest/INT/Engine/Content/Types/SkeletalMeshes/
  @see USkeletalMesh
**/
@:glueCppIncludes("Components/SkeletalMeshComponent.h")
@:uextern extern class USkeletalMeshComponent extends unreal.USkinnedMeshComponent implements unreal.IInterface_CollisionDataProvider {
  
  /**
    Keep track of when animation has been ticked to ensure it is ticked only once per frame.
  **/
  public var LastPoseTickTime : unreal.Float32;
  
  /**
    Threshold for physics asset bodies above which we use an aggregate for broadphase collisions
  **/
  public var RagdollAggregateThreshold : unreal.Int32;
  
  /**
    If bEnableLineCheckWithBounds is true, scale the bounds by this value before doing line check.
  **/
  public var LineCheckBoundsScale : unreal.FVector;
  
  /**
    If true, line checks will test against the bounding box of this skeletal mesh component and return a hit if there is a collision.
  **/
  public var bEnableLineCheckWithBounds : Bool;
  
  /**
    If true, AnimTree has been initialised.
  **/
  public var bAnimTreeInitialised : Bool;
  
  /**
    If false, indicates that on the next call to UpdateSkelPose the RequiredBones array should be recalculated.
  **/
  public var bRequiredBonesUpToDate : Bool;
  
  /**
    Bool that enables debug drawing of the skeleton before it is passed to the physics. Useful for debugging animation-driven physics.
  **/
  public var bShowPrePhysBones : Bool;
  
  /**
    If bForceRefPose was set last tick.
  **/
  public var bOldForceRefPose : Bool;
  
  /**
    If true, force the mesh into the reference pose - is an optimization.
  **/
  public var bForceRefpose : Bool;
  
  /**
    If true TickPose() will not be called from the Component's TickComponent function.
    It will instead be called from Autonomous networking updates. See ACharacter.
  **/
  public var bAutonomousTickPose : Bool;
  
  /**
    Used for per poly collision. In 99% of cases you will be better off using a Physics Asset.
    This BodySetup is per instance because all modification of vertices is done in place
  **/
  public var BodySetup : unreal.UBodySetup;
  
  /**
    Uses skinned data for collision data.
  **/
  public var bEnablePerPolyCollision : Bool;
  
  /**
    pauses this component's animations (doesn't tick them, but still refreshes bones)
  **/
  public var bPauseAnims : Bool;
  
  /**
    Skips Ticking and Bone Refresh.
  **/
  public var bNoSkeletonUpdate : Bool;
  
  /**
    Offset of the root bone from the reference pose. Used to offset bounding box.
  **/
  public var RootBoneTranslation : unreal.FVector;
  
  /**
    weight to blend between simulated results and key-framed positions
    if weight is 1.0, shows only cloth simulation results and 0.0 will show only skinned results
  **/
  public var ClothBlendWeight : unreal.Float32;
  
  /**
    rotation threshold in degree, ranging from 0 to 180
    conduct teleportation if the character's rotation is greater than this threshold in 1 frame.
    Zero or negative values will skip the check
  **/
  public var TeleportRotationThreshold : unreal.Float32;
  
  /**
    conduct teleportation if the character's movement is greater than this threshold in 1 frame.
    Zero or negative values will skip the check
    you can also do force teleport manually using ForceNextUpdateTeleport() / ForceNextUpdateTeleportAndReset()
  **/
  public var TeleportDistanceThreshold : unreal.Float32;
  
  /**
    reset the clothing after moving the clothing position (called teleport)
  **/
  public var bResetAfterTeleport : Bool;
  
  /**
    cloth morph target option
    This option will be applied only before playing because should do pre-calculation to reduce computation time for run-time play
    so it's impossible to change this option in run-time
  **/
  public var bClothMorphTarget : Bool;
  
  /**
    It's worth trying this option when you feel that the current cloth simulation is unstable.
    The scale of the actor is maintained during the simulation.
    It is possible to add the inertia effects to the simulation, through the inertiaScale parameter of the clothing material.
    So with an inertiaScale of 1.0 there should be no visible difference between local space and global space simulation.
    Known issues: - Currently there's simulation issues when this feature is used in 3.x (DE4076) So if localSpaceSim is enabled there's no inertia effect when the global pose of the clothing actor changes.
  **/
  public var bLocalSpaceSimulation : Bool;
  
  /**
    can't collide with part of attached children if total collision volumes exceed 16 capsules or 32 planes per convex
  **/
  public var bCollideWithAttachedChildren : Bool;
  
  /**
    can't collide with part of environment if total collision volumes exceed 16 capsules or 32 planes per convex
  **/
  public var bCollideWithEnvironment : Bool;
  
  /**
    Disable cloth simulation and play original animation without simulation
  **/
  public var bDisableClothSimulation : Bool;
  
  /**
    If we should pass joint position to joints each frame, so that they can be used by motorized joints to drive the
    ragdoll based on the animation.
  **/
  public var bUpdateJointsFromAnimation : Bool;
  
  /**
    If true, simulate physics for this component on a dedicated server.
    This should be set if simulating physics and replicating with a dedicated server.
  **/
  public var bEnablePhysicsOnDedicatedServer : Bool;
  
  /**
    Enables blending in of physics bodies whether Simulate or not
  **/
  public var bBlendPhysics : Bool;
  
  /**
    If we are running physics, should we update non-simulated bones based on the animation bone positions.
  **/
  public var KinematicBonesUpdateType : unreal.EKinematicBonesUpdateToPhysics;
  
  /**
    If true, there is at least one body in the current PhysicsAsset with a valid bone in the current SkeletalMesh
  **/
  public var bHasValidBodies : Bool;
  
  /**
    Used to scale speed of all animations on this skeletal mesh.
  **/
  public var GlobalAnimRateScale : unreal.Float32;
  
  /**
    Cached SpaceBases for Update Rate optimization.
  **/
  public var CachedSpaceBases : unreal.TArray<unreal.FTransform>;
  
  /**
    Cached LocalAtoms for Update Rate optimization.
  **/
  public var CachedLocalAtoms : unreal.TArray<unreal.FTransform>;
  public var AnimationData : unreal.FSingleAnimationPlayData;
  
  /**
    The active animation graph program instance.
  **/
  public var AnimScriptInstance : unreal.UAnimInstance;
  
  /**
    The AnimBlueprint class to use. Use 'SetAnimInstanceClass' to change at runtime.
  **/
  public var AnimBlueprintGeneratedClass : unreal.UAnimBlueprintGeneratedClass;
  #if WITH_EDITORONLY_DATA
  
  /**
    The blueprint for creating an AnimationScript.
  **/
  public var AnimationBlueprint_DEPRECATED : unreal.UAnimBlueprint;
  #end // WITH_EDITORONLY_DATA
  
  /**
    Whether to use Animation Blueprint or play Single Animation Asset.
  **/
  private var AnimationMode : unreal.EAnimationMode;
  
}
