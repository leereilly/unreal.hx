/**
   * 
   * WARNING! This file was autogenerated by: 
   *  _   _ _____     ___   _   _ __   __ 
   * | | | |  ___|   /   | | | | |\ \ / / 
   * | | | | |__    / /| | | |_| | \ V /  
   * | | | |  __|  / /_| | |  _  | /   \  
   * | |_| | |___  \___  | | | | |/ /^\ \ 
   *  \___/\____/      |_/ \_| |_/\/   \/ 
   * 
   * This file was autogenerated by UE4HaxeExternGenerator using UHT definitions. It only includes UPROPERTYs and UFUNCTIONs. Do not modify it!
   * In order to add more definitions, create or edit a type with the same name/package, but with an `_Extra` suffix
**/
package unreal;


/**
  The GameMode defines the game being played. It governs the game rules, scoring, what actors
  are allowed to exist in this game type, and who may enter the game.
  
  It is only instanced on the server and will never exist on the client.
  
  A GameMode actor is instantiated when the level is initialized for gameplay in
  C++ UGameEngine::LoadMap().
  
  The class of this GameMode actor is determined by (in order) either the URL ?game=xxx,
  the GameMode Override value set in the World Settings, or the DefaultGameMode entry set
  in the game's Project Settings.
  
  @see https://docs.unrealengine.com/latest/INT/Gameplay/Framework/GameMode/index.html
**/
@:glueCppIncludes("GameFramework/GameMode.h")
@:uextern extern class AGameMode extends unreal.AInfo {
  
  /**
    Returns the current match state, this is an accessor to protect the state machine flow
  **/
  @:thisConst @:final public function GetMatchState() : unreal.FName;
  
  /**
    Returns true if the match state is InProgress or later
  **/
  @:thisConst public function HasMatchStarted() : Bool;
  
  /**
    Returns true if the match state is InProgress or other gameplay state
  **/
  @:thisConst public function IsMatchInProgress() : Bool;
  
  /**
    Returns true if the match state is WaitingPostMatch or later
  **/
  @:thisConst public function HasMatchEnded() : Bool;
  
  /**
    Transitions to WaitingToStart and calls BeginPlay on actors.
  **/
  public function StartPlay() : Void;
  
  /**
    Transition from WaitingToStart to InProgress. You can call this manually, will also get called if ReadyToStartMatch returns true
  **/
  public function StartMatch() : Void;
  
  /**
    Transition from InProgress to WaitingPostMatch. You can call this manually, will also get called if ReadyToEndMatch returns true
  **/
  public function EndMatch() : Void;
  
  /**
    Restart the game, by default travel to the current map
  **/
  public function RestartGame() : Void;
  
  /**
    Return to main menu, and disconnect any players
  **/
  public function ReturnToMainMenuHost() : Void;
  
  /**
    Report that a match has failed due to unrecoverable error
  **/
  public function AbortMatch() : Void;
  
  /**
    Implementable event to respond to match state changes
  **/
  private function K2_OnSetMatchState(NewState : unreal.FName) : Void;
  
  /**
    @return True if ready to Start Match. Games should override this
  **/
  private function ReadyToStartMatch() : Bool;
  
  /**
    @return true if ready to End Match. Games should override this
  **/
  private function ReadyToEndMatch() : Bool;
  
  /**
    Time a playerstate will stick around in an inactive state after a player logout
  **/
  private var InactivePlayerStateLifeSpan : unreal.Float32;
  
  /**
    Handy alternate short names for GameMode classes (e.g. "DM" could be an alias for "MyProject.MyGameModeMP_DM".
  **/
  private var GameModeClassAliases : unreal.TArray<unreal.FGameClassShortName>;
  
  /**
    PlayerStates of players who have disconnected from the server (saved in case they reconnect)
  **/
  public var InactivePlayerArray : unreal.TArray<unreal.APlayerState>;
  
  /**
    GameState is used to replicate game state relevant properties to all clients.
  **/
  public var GameState : unreal.AGameState;
  
  /**
    Class of GameState associated with this GameMode.
  **/
  public var GameStateClass : unreal.TSubclassOf<unreal.AGameState>;
  
  /**
    A PlayerState of this class will be associated with every player to replicate relevant player information to all clients.
  **/
  public var PlayerStateClass : unreal.TSubclassOf<unreal.APlayerState>;
  
  /**
    The PlayerController class used when spectating a network replay.
  **/
  public var ReplaySpectatorPlayerControllerClass : unreal.TSubclassOf<unreal.APlayerController>;
  
  /**
    The pawn class used by the PlayerController for players when spectating.
  **/
  public var SpectatorClass : unreal.TSubclassOf<unreal.ASpectatorPawn>;
  
  /**
    The class of PlayerController to spawn for players logging in.
  **/
  public var PlayerControllerClass : unreal.TSubclassOf<unreal.APlayerController>;
  
  /**
    Contains strings describing localized game agnostic messages.
  **/
  public var EngineMessageClass : unreal.TSubclassOf<unreal.ULocalMessage>;
  
  /**
    Number of players that are still traveling from a previous map
  **/
  public var NumTravellingPlayers : unreal.Int32;
  
  /**
    Game Session handles login approval, arbitration, online game interface
  **/
  public var GameSession : unreal.AGameSession;
  
  /**
    Minimum time before player can respawn after dying.
  **/
  public var MinRespawnDelay : unreal.Float32;
  
  /**
    number of non-human players (AI controlled but participating as a player).
  **/
  public var NumBots : unreal.Int32;
  
  /**
    Current number of human players.
  **/
  public var NumPlayers : unreal.Int32;
  
  /**
    Current number of spectators.
  **/
  public var NumSpectators : unreal.Int32;
  
  /**
    HUD class this game uses.
  **/
  public var HUDClass : unreal.TSubclassOf<unreal.AHUD>;
  
  /**
    The default pawn class used by players.
  **/
  public var DefaultPawnClass : unreal.TSubclassOf<unreal.APawn>;
  
  /**
    Save options string and parse it when needed
  **/
  public var OptionsString : unreal.FString;
  
  /**
    Whether the game should immediately start when the first player logs in. Affects the default behavior of ReadyToStartMatch
  **/
  public var bDelayedStart : Bool;
  
  /**
    Whether players should immediately spawn when logging in, or stay as spectators until they manually spawn
  **/
  public var bStartPlayersAsSpectators : Bool;
  
  /**
    Whether the game is pauseable.
  **/
  public var bPauseable : Bool;
  
  /**
    perform map travels using SeamlessTravel() which loads in the background and doesn't disconnect clients
    @see World::SeamlessTravel()
  **/
  public var bUseSeamlessTravel : Bool;
  
  /**
    Alters the synthetic bandwidth limit for a running game.
  **/
  public function SetBandwidthLimit(AsyncIOBandwidthLimit : unreal.Float32) : Void;
  
  /**
    Overridable function to determine whether an Actor should have Reset called when the game has Reset called on it.
    Default implementation returns true
    @param ActorToReset The actor to make a determination for
    @return true if ActorToReset should have Reset() called on it while restarting the game,
                    false if the GameMode will manually reset it or if the actor does not need to be reset
  **/
  public function ShouldReset(ActorToReset : unreal.AActor) : Bool;
  
  /**
    Overridable function called when resetting level.
    Default implementation calls Reset() on all actors except GameMode and Controllers
  **/
  public function ResetLevel() : Void;
  
  /**
    Total number of players
  **/
  public function GetNumPlayers() : unreal.Int32;
  
  /**
    Notification that a player has successfully logged in, and has been given a player controller
  **/
  public function K2_PostLogin(NewPlayer : unreal.APlayerController) : Void;
  
  /**
    @Returns true if NewPlayerController may only join the server as a spectator.
  **/
  @:thisConst public function MustSpectate(NewPlayerController : unreal.APlayerController) : Bool;
  
  /**
    returns default pawn class for given controller
  **/
  public function GetDefaultPawnClassForController(InController : unreal.AController) : unreal.UClass;
  
  /**
    Called when StartSpot is selected for spawning NewPlayer to allow optional initialization.
  **/
  public function InitStartSpot(StartSpot : unreal.AActor, NewPlayer : unreal.AController) : Void;
  
  /**
    @param       NewPlayer - Controller for whom this pawn is spawned
    @param       StartSpot - PlayerStart at which to spawn pawn
    @return      a pawn of the default pawn class
  **/
  public function SpawnDefaultPawnFor(NewPlayer : unreal.AController, StartSpot : unreal.AActor) : unreal.APawn;
  
  /**
    Implementable event when a Controller with a PlayerState leaves the match.
  **/
  public function K2_OnLogout(ExitingController : unreal.AController) : Void;
  
  /**
    Return whether Viewer is allowed to spectate from the point of view of ViewTarget.
  **/
  public function CanSpectate(Viewer : unreal.APlayerController, ViewTarget : unreal.APlayerState) : Bool;
  
  /**
    Sets the name for a controller
    @param Controller    The controller of the player to change the name of
    @param NewName               The name to set the player to
    @param bNameChange   Whether the name is changing or if this is the first time it has been set
  **/
  public function ChangeName(Controller : unreal.AController, NewName : unreal.FString, bNameChange : Bool) : Void;
  
  /**
    Overridable event for GameMode blueprint to respond to a change name call
    @param Controller    The controller of the player to change the name of
    @param NewName               The name to set the player to
    @param bNameChange   Whether the name is changing or if this is the first time it has been set
  **/
  public function K2_OnChangeName(Other : unreal.AController, NewName : unreal.FString, bNameChange : Bool) : Void;
  
  /**
    Return the 'best' player start for this player to start from.
    @param Player The AController for whom we are choosing a Player Start
    @param IncomingName Specifies the tag of a Player Start to use
    @returns Actor chosen as player start (usually a PlayerStart)
  **/
  public function FindPlayerStart(Player : unreal.AController, IncomingName : unreal.FString) : unreal.AActor;
  @:final public function K2_FindPlayerStart(Player : unreal.AController) : unreal.AActor;
  
  /**
    Return the 'best' player start for this player to start from.
    Default implementation just returns the first PlayerStart found.
    @param Player is the controller for whom we are choosing a playerstart
    @returns AActor chosen as player start (usually a PlayerStart)
  **/
  public function ChoosePlayerStart(Player : unreal.AController) : unreal.AActor;
  
  /**
    @return true if it's valid to call RestartPlayer. Will call Player->CanRestartPlayer
  **/
  public function PlayerCanRestart(Player : unreal.APlayerController) : Bool;
  public function K2_OnSwapPlayerControllers(OldPC : unreal.APlayerController, NewPC : unreal.APlayerController) : Void;
  public function K2_OnRestartPlayer(NewPlayer : unreal.AController) : Void;
  
}
