/**
  This file was autogenerated by UE4HaxeExternGenerator using UHT definitions. It only includes UPROPERTYs and UFUNCTIONs. Do not modify it!
  In order to add more definitions, create or edit a type with the same name/package, but with a `_Extra` suffix
**/
package unreal;


/**
  PrimitiveComponents are SceneComponents that contain or generate some sort of geometry, generally to be rendered or used as collision data.
  There are several subclasses for the various types of geometry, but the most common by far are the ShapeComponents (Capsule, Sphere, Box), StaticMeshComponent, and SkeletalMeshComponent.
  ShapeComponents generate geometry that is used for collision detection but are not rendered, while StaticMeshComponents and SkeletalMeshComponents contain pre-built geometry that is rendered, but can also be used for collision detection.
**/
@:glueCppIncludes("Components/PrimitiveComponent.h")
@:uextern extern class UPrimitiveComponent extends unreal.USceneComponent implements unreal.INavRelevantInterface {
  
  /**
    Tick function for physics ticking *
  **/
  public var PostPhysicsComponentTick : unreal.FPrimitiveComponentPostPhysicsTickFunction;
  
  /**
    Determine whether a Character can step up onto this component.
    This controls whether they can try to step up on it when they bump in to it, not whether they can walk on it after landing on it.
    @see FWalkableSlopeOverride
  **/
  public var CanCharacterStepUpOn : unreal.ECanBeCharacterBase;
  
  /**
    The value of WorldSettings->TimeSeconds for the frame when this component was last rendered.  This is written
    from the render thread, which is up to a frame behind the game thread, so you should allow this time to
    be at least a frame behind the game thread's world time before you consider the actor non-visible.
  **/
  public var LastRenderTime : unreal.Float32;
  
  /**
    Last time the component was submitted for rendering (called FScene::AddPrimitive).
  **/
  public var LastSubmitTime : unreal.Float32;
  
  /**
    Scales the bounds of the object.
    This is useful when using World Position Offset to animate the vertices of the object outside of its bounds.
    Warning: Increasing the bounds of an object will reduce performance and shadow quality!
    Currently only used by StaticMeshComponent and SkeletalMeshComponent.
  **/
  public var BoundsScale : unreal.Float32;
  
  /**
    If true then DoCustomNavigableGeometryExport will be called to collect navigable geometry of this component.
  **/
  private var bHasCustomNavigableGeometry : unreal.EHasCustomNavigableGeometry;
  
  /**
    Whether this component can potentially influence navigation
  **/
  public var bCanEverAffectNavigation : Bool;
  
  /**
    Physics scene information for this component, holds a single rigid body with multiple shapes.
  **/
  public var BodyInstance : unreal.FBodyInstance;
  
  /**
    Multiplier used to scale the Light Propagation Volume light injection bias, to reduce light bleeding.
    Set to 0 for no bias, 1 for default or higher for increased biasing (e.g. for
    thin geometry such as walls)
  **/
  public var LpvBiasMultiplier : unreal.Float32;
  
  /**
    Used for precomputed visibility
  **/
  public var VisibilityId : unreal.Int32;
  
  /**
    Translucent objects with a lower sort priority draw behind objects with a higher priority.
    Translucent objects with the same priority are rendered from back-to-front based on their bounds origin.
    
    Ignored if the object is not translucent.  The default priority is zero.
    Warning: This should never be set to a non-default value unless you know what you are doing, as it will prevent the renderer from sorting correctly.
    It is especially problematic on dynamic gameplay effects.
  **/
  public var TranslucencySortPriority : unreal.Int32;
  
  /**
    Optionally write this 0-255 value to the stencil buffer in CustomDepth pass (Requires project setting or r.CustomDepth == 3)
  **/
  public var CustomDepthStencilValue : unreal.Int32;
  
  /**
    If true, this component will be rendered in the CustomDepth pass (usually used for outlines)
  **/
  public var bRenderCustomDepth : Bool;
  
  /**
    Composite the drawing of this component onto the scene after post processing (only applies to editor drawing)
  **/
  public var bUseEditorCompositing : Bool;
  
  /**
    If this is True, this component must always be loaded on servers, even if Hidden and CollisionEnabled is NoCollision
  **/
  public var AlwaysLoadOnServer : Bool;
  
  /**
    If this is True, this component must always be loaded on clients, even if Hidden and CollisionEnabled is NoCollision.
  **/
  public var AlwaysLoadOnClient : Bool;
  
  /**
    Will ignore radial forces applied to this component.
  **/
  public var bIgnoreRadialForce : Bool;
  
  /**
    Will ignore radial impulses applied to this component.
  **/
  public var bIgnoreRadialImpulse : Bool;
  
  /**
    If true, asynchronous static build lighting will be enqueued to be applied to this
  **/
  public var bStaticLightingBuildEnqueued : Bool;
  public var bHasCachedStaticLighting : Bool;
  
  /**
    Quality of indirect lighting for Movable primitives.  This has a large effect on Indirect Lighting Cache update time.
  **/
  public var IndirectLightingCacheQuality : unreal.EIndirectLightingCacheQuality;
  
  /**
    Whether to light this component and any attachments as a group.  This only has effect on the root component of an attachment tree.
    When enabled, attached component shadowing settings like bCastInsetShadow, bCastVolumetricTranslucentShadow, etc, will be ignored.
    This is useful for improving performance when multiple movable components are attached together.
  **/
  public var bLightAttachmentsAsGroup : Bool;
  
  /**
    Whether to light this primitive as if it were static, including generating lightmaps.
    This only has an effect for component types that can bake lighting, like static mesh components.
    This is useful for moving meshes that don't change significantly.
  **/
  public var bLightAsIfStatic : Bool;
  
  /**
    Whether this primitive should cast dynamic shadows as if it were a two sided material.
  **/
  public var bCastShadowAsTwoSided : Bool;
  
  /**
    If true, the primitive will cast shadows even if bHidden is true.
    Controls whether the primitive should cast shadows when hidden.
    This flag is only used if CastShadow is true.
  **/
  public var bCastHiddenShadow : Bool;
  
  /**
    Whether this component should cast shadows from lights that have bCastShadowsFromCinematicObjectsOnly enabled.
    This is useful for characters in a cinematic with special cinematic lights, where the cost of shadowmap rendering of the environment is undesired.
  **/
  public var bCastCinematicShadow : Bool;
  
  /**
    Whether this component should create a per-object shadow that gives higher effective shadow resolution.
    Useful for cinematic character shadowing. Assumed to be enabled if bSelfShadowOnly is enabled.
  **/
  public var bCastInsetShadow : Bool;
  
  /**
    When enabled, the component will be rendering into the far shadow cascades (only for directional lights).
  **/
  public var bCastFarShadow : Bool;
  
  /**
    When enabled, the component will only cast a shadow on itself and not other components in the world.  This is especially useful for first person weapons, and forces bCastInsetShadow to be enabled.
  **/
  public var bSelfShadowOnly : Bool;
  
  /**
    Whether the object should cast a volumetric translucent shadow.
    Volumetric translucent shadows are useful for primitives with smoothly changing opacity like particles representing a volume,
    But have artifacts when used on highly opaque surfaces.
  **/
  public var bCastVolumetricTranslucentShadow : Bool;
  
  /**
    Whether the object should cast a static shadow from shadow casting lights.  This flag is only used if CastShadow is true.
  **/
  public var bCastStaticShadow : Bool;
  
  /**
    Controls whether the primitive should cast shadows in the case of non precomputed shadowing.  This flag is only used if CastShadow is true. *
  **/
  public var bCastDynamicShadow : Bool;
  
  /**
    Controls whether the primitive should affect dynamic distance field lighting methods.  This flag is only used if CastShadow is true. *
  **/
  public var bAffectDistanceFieldLighting : Bool;
  
  /**
    Controls whether the primitive should inject light into the Light Propagation Volume.  This flag is only used if CastShadow is true. *
  **/
  public var bAffectDynamicIndirectLighting : Bool;
  
  /**
    Controls whether the primitive component should cast a shadow or not.
    
    This flag is ignored (no shadows will be generated) if all materials on this component have an Unlit shading model.
  **/
  public var CastShadow : Bool;
  
  /**
    If true a hit-proxy will be generated for each instance of instanced static meshes
  **/
  public var bHasPerInstanceHitProxies : Bool;
  
  /**
    If true, forces mips for textures used by this component to be resident when this component's level is loaded.
  **/
  public var bForceMipStreaming : Bool;
  
  /**
    If this is True, this component can be selected in the editor.
  **/
  public var bSelectable : Bool;
  
  /**
    Whether to render the primitive in the depth only pass.
    This should generally be true for all objects, and let the renderer make decisions about whether to render objects in the depth only pass.
    @todo - if any rendering features rely on a complete depth only pass, this variable needs to go away.
  **/
  public var bUseAsOccluder : Bool;
  
  /**
    Treat this primitive as part of the background for occlusion purposes. This can be used as an optimization to reduce the cost of rendering skyboxes, large ground planes that are part of the vista, etc.
  **/
  public var bTreatAsBackgroundForOcclusion : Bool;
  
  /**
    If this is True, this component will only be visible when the view actor is the component's owner, directly or indirectly.
  **/
  public var bOnlyOwnerSee : Bool;
  
  /**
    If this is True, this component won't be visible when the view actor is the component's owner, directly or indirectly.
  **/
  public var bOwnerNoSee : Bool;
  
  /**
    Whether the primitive receives decals.
  **/
  public var bReceivesDecals : Bool;
  
  /**
    If true, this component will be rendered in the main pass (z prepass, basepass, transparency)
  **/
  public var bRenderInMainPass : Bool;
  
  /**
    true if the primitive has motion blur velocity meshes
  **/
  public var bHasMotionBlurVelocityMeshes : Bool;
  
  /**
    Whether to accept cull distance volumes to modify cached cull distance.
  **/
  public var bAllowCullDistanceVolume : Bool;
  
  /**
    True if the primitive should be rendered using ViewOwnerDepthPriorityGroup if viewed by its owner.
  **/
  public var bUseViewOwnerDepthPriorityGroup : Bool;
  
  /**
    If true, component sweeps will return the material in their hit result.
    @see MoveComponent(), FHitResult
  **/
  public var bReturnMaterialOnMove : Bool;
  
  /**
    If true, component sweeps with this component should trace against complex collision during movement (for example, each triangle of a mesh).
    If false, collision will be resolved against simple collision bounds instead.
    @see MoveComponent()
  **/
  public var bTraceComplexOnMove : Bool;
  
  /**
    If true, this component will look for collisions on both physic scenes during movement.
    Only required if the asynchronous physics scene is enabled and has geometry in it, and you wish to test for collisions with objects in that scene.
    @see MoveComponent()
  **/
  public var bCheckAsyncSceneOnMove : Bool;
  
  /**
    If true, this component will generate individual overlaps for each overlapping physics body if it is a multi-body component. When false, this component will
    generate only one overlap, regardless of how many physics bodies it has and how many of them are overlapping another component/body. This flag has no
    influence on single body components.
  **/
  public var bMultiBodyOverlap : Bool;
  
  /**
    If true, this component will generate overlap events when it is overlapping other components (eg Begin Overlap).
    Both components (this and the other) must have this enabled for overlap events to occur.
    
    @see [Overlap Events](https://docs.unrealengine.com/latest/INT/Engine/Physics/Collision/index.html#overlapandgenerateoverlapevents)
    @see UpdateOverlaps(), BeginComponentOverlap(), EndComponentOverlap()
  **/
  public var bGenerateOverlapEvents : Bool;
  
  /**
    Indicates if we'd like to create physics state all the time (for collision and simulation).
    If you set this to false, it still will create physics state if collision or simulation activated.
    This can help performance if you'd like to avoid overhead of creating physics state when triggers
  **/
  public var bAlwaysCreatePhysicsState : Bool;
  
  /**
    The scene depth priority group to draw the primitive in, if it's being viewed by its owner.
  **/
  public var ViewOwnerDepthPriorityGroup : unreal.ESceneDepthPriorityGroup;
  
  /**
    The scene depth priority group to draw the primitive in.
  **/
  public var DepthPriorityGroup : unreal.ESceneDepthPriorityGroup;
  
  /**
    The distance to cull this primitive at.
    A CachedMaxDrawDistance of 0 indicates that the primitive should not be culled by distance.
  **/
  public var CachedMaxDrawDistance : unreal.Float32;
  
  /**
    Max draw distance exposed to LDs. The real max draw distance is the min (disregarding 0) of this and volumes affecting this object.
  **/
  public var LDMaxDrawDistance : unreal.Float32;
  
  /**
    The minimum distance at which the primitive should be rendered,
    measured in world space units from the center of the primitive's bounding sphere to the camera position.
  **/
  public var MinDrawDistance : unreal.Float32;
  
}
